# DSL 实现设计文档

## 一、总体架构

### 1.1 模块划分

```
data_next/
├── core/
│   ├── clock.py              # 时钟管理（已有）
│   ├── variable.py           # 变量存储（已有）
│   ├── expression_node.py    # 表达式节点（已有，需扩展）
│   ├── engine.py             # 执行引擎（已有，需扩展）
│   ├── instance.py           # 实例基类与注册（新建）
│   └── parser.py             # DSL 解析器（新建）
├── algorithms/               # 算法库（新建）
│   ├── __init__.py
│   ├── base.py              # 算法基类
│   ├── pid.py               # PID 算法
│   ├── sine_wave.py         # SINE_WAVE 算法
│   ├── square_wave.py       # SQUARE_WAVE 算法
│   ├── triangle_wave.py     # TRIANGLE_WAVE 算法
│   ├── list_wave.py         # LIST_WAVE 算法
│   └── ...
├── models/                  # 模型库（新建）
│   ├── __init__.py
│   ├── base.py              # 模型基类
│   ├── cylindrical_tank.py   # 圆柱水箱模型
│   ├── valve.py             # 阀门模型
│   └── ...
└── functions/               # 无状态函数库（新建）
    ├── __init__.py
    └── math_functions.py    # 数学函数
```

### 1.2 数据流

```
YAML 配置
  ↓
DSL 解析器 (parser.py)
  ↓
配置对象 (ProgramConfig)
  ↓
实例工厂 (InstanceFactory)
  ↓
依赖分析 (DependencyAnalyzer)
  ↓
拓扑排序 (TopologicalSorter)
  ↓
执行引擎 (UnifiedEngine)
  ↓
变量存储 (VariableStore) ← 统一存储所有变量和实例属性的历史数据
```

### 1.3 历史数据存储机制

**核心要求**：
- 每个 Variable 需要存储历史数据（支持 `variable_name[-30]` 语法）
- 每个 AlgorithmInstance 的每个属性也需要存储历史数据（支持 `instance.attribute[-30]` 语法）
- 所有历史数据统一存储在 `VariableStore` 中，使用 `record_length` 配置历史记录长度

**存储键名规则**：
- Variable：直接使用变量名，如 `non_sense_3`
- 算法/模型属性：使用 `instance_name.attribute_name`，如 `pid1.mv`、`tank1.level`

**访问方式**：
- 当前值：`variable_name` 或 `instance.attribute`
- 历史值：`variable_name[-30]` 或 `instance.attribute[-30]`

## 二、核心模块设计

### 2.1 实例基类系统 (`core/instance.py`)

#### 2.1.1 算法基类

```python
class BaseAlgorithm:
    """算法基类"""
    
    # 类属性：定义需要存储的属性列表
    stored_attributes: List[str] = []
    
    # 类属性：定义默认参数
    default_params: Dict[str, Any] = {}
    
    def __init__(self, cycle_time: float, **kwargs):
        """
        初始化算法实例
        
        Args:
            cycle_time: 控制器周期（秒），由引擎自动注入
            **kwargs: 其他初始化参数（来自 DSL 的 init_args）
        """
        self.cycle_time = cycle_time
        # 使用 kwargs 覆盖 default_params
        for key, value in {**self.default_params, **kwargs}.items():
            setattr(self, key, value)
    
    def execute(self, **kwargs) -> None:
        """
        执行算法（更新内部状态）
        
        Args:
            **kwargs: 输入参数（从表达式中解析得到）
        """
        raise NotImplementedError
```

#### 2.1.2 模型基类

```python
class BaseModel:
    """模型基类"""
    
    # 类属性：定义需要存储的属性列表
    stored_attributes: List[str] = []
    
    # 类属性：定义默认参数
    default_params: Dict[str, Any] = {}
    
    def __init__(self, cycle_time: float, **kwargs):
        """
        初始化模型实例
        
        Args:
            cycle_time: 控制器周期（秒），由引擎自动注入
            **kwargs: 其他初始化参数（来自 DSL 的 init_args）
        """
        self.cycle_time = cycle_time
        # 使用 kwargs 覆盖 default_params
        for key, value in {**self.default_params, **kwargs}.items():
            setattr(self, key, value)
    
    def execute(self, **kwargs) -> None:
        """
        执行模型计算（更新内部状态）
        
        Args:
            **kwargs: 输入参数（从表达式中解析得到）
        """
        raise NotImplementedError
```

#### 2.1.3 类型注册表

```python
class InstanceRegistry:
    """实例类型注册表"""
    
    _algorithms: Dict[str, Type[BaseAlgorithm]] = {}
    _models: Dict[str, Type[BaseModel]] = {}
    _functions: Dict[str, Callable] = {}
    
    @classmethod
    def register_algorithm(cls, name: str, algorithm_class: Type[BaseAlgorithm]):
        """注册算法类型"""
        cls._algorithms[name.upper()] = algorithm_class
    
    @classmethod
    def register_model(cls, name: str, model_class: Type[BaseModel]):
        """注册模型类型"""
        cls._models[name.upper()] = model_class
    
    @classmethod
    def register_function(cls, name: str, func: Callable):
        """注册无状态函数"""
        cls._functions[name] = func
    
    @classmethod
    def get_algorithm(cls, name: str) -> Type[BaseAlgorithm]:
        """获取算法类"""
        return cls._algorithms.get(name.upper())
    
    @classmethod
    def get_model(cls, name: str) -> Type[BaseModel]:
        """获取模型类"""
        return cls._models.get(name.upper())
    
    @classmethod
    def get_function(cls, name: str) -> Callable:
        """获取函数"""
        return cls._functions.get(name)
```

### 2.2 DSL 解析器 (`core/parser.py`)

#### 2.2.1 配置对象

```python
@dataclass
class ProgramItem:
    """程序项配置"""
    name: str
    type: str
    init_args: Dict[str, Any]
    expression: str

@dataclass
class ProgramConfig:
    """程序配置"""
    clock: ClockConfig
    program: List[ProgramItem]
    record_length: int = 1000  # 历史记录长度（所有变量和属性都使用这个长度）
    max_lag_steps: int = 0  # 已废弃，使用 record_length
```

#### 2.2.2 解析器

```python
class DSLParser:
    """DSL 解析器"""
    
    def parse(self, config_path: str) -> ProgramConfig:
        """
        解析 YAML 配置文件
        
        Args:
            config_path: YAML 配置文件路径
            
        Returns:
            ProgramConfig 对象
        """
        with open(config_path, 'r', encoding='utf-8') as f:
            data = yaml.safe_load(f)
        
        # 解析 clock 配置
        clock_config = self._parse_clock_config(data)
        
        # 解析 program 列表
        program_items = []
        for item_data in data.get('program', []):
            program_items.append(ProgramItem(
                name=item_data['name'],
                type=item_data['type'],
                init_args=item_data.get('init_args', {}),
                expression=item_data['expression']
            ))
        
        # 解析历史记录长度
        record_length = self._parse_record_length(data)
        
        return ProgramConfig(
            clock=clock_config,
            program=program_items,
            record_length=record_length
        )
    
    def _parse_clock_config(self, data: Dict) -> ClockConfig:
        """解析时钟配置"""
        # 从 data 中提取 clock 相关配置
        # 如果 data 中没有 clock 配置，使用默认值
        return ClockConfig(
            cycle_time=data.get('cycle_time', 0.5),
            start_time=data.get('start_time', 0.0),
            mode=ClockMode.GENERATOR,  # 默认离线模式
            sample_interval=data.get('sample_interval'),
            time_format=data.get('time_format')
        )
    
    def _parse_record_length(self, data: Dict) -> int:
        """解析历史记录长度配置"""
        return data.get('record_length', 1000)
```

### 2.3 依赖分析器 (`core/dependency.py`)

```python
class DependencyAnalyzer:
    """依赖关系分析器"""
    
    def analyze(self, program_items: List[ProgramItem]) -> Dict[str, List[str]]:
        """
        分析依赖关系
        
        Args:
            program_items: 程序项列表
            
        Returns:
            依赖图：{变量名: [依赖的变量名列表]}
        """
        dependency_graph: Dict[str, List[str]] = {}
        
        for item in program_items:
            deps = self._extract_dependencies(item.expression, item.name)
            dependency_graph[item.name] = deps
        
        return dependency_graph
    
    def _extract_dependencies(self, expression: str, self_name: str) -> List[str]:
        """
        从表达式中提取依赖
        
        支持：
        - 属性访问：tank1.level -> tank1
        - 方法调用参数：pid1.execute(pv=tank1.level) -> tank1
        - lag 语法：v1[-30] -> v1
        - 函数调用：abs(v1) -> v1
        """
        # 使用 AST 解析表达式
        tree = ast.parse(expression, mode='eval')
        deps = set()
        
        class DependencyVisitor(ast.NodeVisitor):
            def visit_Name(self, node):
                if node.id != self_name:
                    deps.add(node.id)
            
            def visit_Attribute(self, node):
                # 处理 tank1.level -> tank1
                if isinstance(node.value, ast.Name):
                    deps.add(node.value.id)
                self.generic_visit(node)
        
        visitor = DependencyVisitor()
        visitor.visit(tree)
        
        return list(deps)
```

### 2.4 实例工厂 (`core/factory.py`)

```python
class InstanceFactory:
    """实例工厂"""
    
    def __init__(self, cycle_time: float):
        self.cycle_time = cycle_time
        self._instances: Dict[str, Any] = {}
    
    def create_instance(self, item: ProgramItem) -> Any:
        """
        创建实例
        
        Args:
            item: 程序项配置
            
        Returns:
            创建的实例对象
        """
        if item.name in self._instances:
            return self._instances[item.name]
        
        instance = None
        
        if item.type.upper() == 'VARIABLE':
            # Variable 类型不需要创建实例
            return None
        
        # 查找算法或模型类
        algorithm_class = InstanceRegistry.get_algorithm(item.type)
        model_class = InstanceRegistry.get_model(item.type)
        
        if algorithm_class:
            instance = algorithm_class(cycle_time=self.cycle_time, **item.init_args)
        elif model_class:
            instance = model_class(cycle_time=self.cycle_time, **item.init_args)
        else:
            raise ValueError(f"未知的类型: {item.type}")
        
        self._instances[item.name] = instance
        return instance
    
    def get_instance(self, name: str) -> Any:
        """获取已创建的实例"""
        return self._instances.get(name)
```

### 2.5 表达式节点扩展 (`core/expression_node.py`)

#### 2.5.1 算法节点

```python
class AlgorithmNode:
    """算法节点（执行算法实例的 execute 方法）"""
    
    def __init__(self, instance: BaseAlgorithm, expression: str, stored_attributes: List[str], instance_name: str):
        self.instance = instance
        self.expression = expression
        self.stored_attributes = stored_attributes
        self.instance_name = instance_name  # 实例名称，用于存储属性
        self._parsed_args = self._parse_expression(expression)
    
    def _parse_expression(self, expression: str) -> Dict[str, str]:
        """
        解析表达式，提取方法调用的参数
        
        例如：pid1.execute(pv=tank1.level, sv=sin1.out)
        返回：{'pv': 'tank1.level', 'sv': 'sin1.out'}
        """
        # 使用 AST 解析
        tree = ast.parse(expression, mode='eval')
        
        if isinstance(tree.body, ast.Call):
            args = {}
            for keyword in tree.body.keywords:
                # 将参数值转换为字符串（用于后续解析）
                args[keyword.arg] = ast.unparse(keyword.value)
            return args
        return {}
    
    def step(self, vars_store: VariableStore, instances: Dict[str, Any], instance_name_map: Dict[Any, str], cycle_time: float) -> None:
        """
        执行一个周期
        
        Args:
            vars_store: 变量存储
            instances: 实例字典（用于解析属性访问）
            instance_name_map: 实例对象 -> 实例名称的映射
            cycle_time: 控制器周期
        """
        # 解析参数值（支持属性访问和历史数据访问）
        resolved_args = {}
        for param_name, param_expr in self._parsed_args.items():
            value = self._resolve_expression(param_expr, vars_store, instances)
            resolved_args[param_name] = value
        
        # 调用 execute 方法
        self.instance.execute(**resolved_args)
        
        # 存储需要存储的属性（自动存储到 VariableStore，支持历史数据）
        for attr_name in self.stored_attributes:
            if hasattr(self.instance, attr_name):
                value = getattr(self.instance, attr_name)
                # 使用 instance_name.attribute_name 作为存储键
                # 每次 set 都会自动追加到历史缓冲区
                vars_store.set(f"{self.instance_name}.{attr_name}", value)
    
    def _resolve_expression(self, expr: str, vars_store: VariableStore, instances: Dict[str, Any]) -> float:
        """
        解析表达式，获取值（支持属性访问和历史数据）
        
        例如：
        - tank1.level -> 从 VariableStore 获取 tank1.level 的当前值
        - tank1.level[-30] -> 从 VariableStore 获取 tank1.level 的 30 步之前的值
        - non_sense_1[-30] -> 从 VariableStore 获取 non_sense_1 的 30 步之前的值
        """
        # 使用 AST 解析表达式
        tree = ast.parse(expr, mode='eval')
        
        # 处理属性访问和历史数据访问
        if isinstance(tree.body, ast.Subscript):
            # 处理 [lag_steps] 语法
            if isinstance(tree.body.value, ast.Attribute):
                # instance.attribute[-30]
                instance_name = tree.body.value.value.id
                attr_name = tree.body.value.attr
                lag_steps = -ast.literal_eval(tree.body.slice)  # 转换为正数
                var_key = f"{instance_name}.{attr_name}"
                return vars_store.get_with_lag(var_key, lag_steps, 0.0)
            elif isinstance(tree.body.value, ast.Name):
                # variable_name[-30]
                var_name = tree.body.value.id
                lag_steps = -ast.literal_eval(tree.body.slice)  # 转换为正数
                return vars_store.get_with_lag(var_name, lag_steps, 0.0)
        elif isinstance(tree.body, ast.Attribute):
            # instance.attribute（当前值）
            instance_name = tree.body.value.id
            attr_name = tree.body.attr
            var_key = f"{instance_name}.{attr_name}"
            return vars_store.get(var_key, 0.0)
        elif isinstance(tree.body, ast.Name):
            # variable_name（当前值）
            var_name = tree.body.id
            return vars_store.get(var_name, 0.0)
        
        # 其他情况（常量等）
        return ast.literal_eval(tree.body)
```

#### 2.5.2 表达式节点（Variable 类型）

```python
class VariableNode(ExpressionNode):
    """变量节点（执行表达式计算）"""
    
    def __init__(self, config: ExpressionConfig, instances: Dict[str, Any]):
        super().__init__(config)
        self.instances = instances
        # 扩展 EvalContext，支持属性访问和函数调用
    
    def step(self, vars_store: VariableStore, t: float) -> float:
        """执行一个周期"""
        ctx = ExtendedEvalContext(vars_store, t, self.instances)
        value = self._expr.eval(ctx)
        vars_store.set(self.name, value)
        return value
```

#### 2.5.3 扩展的 EvalContext

```python
class ExtendedEvalContext(EvalContext):
    """扩展的执行上下文（支持属性访问、函数调用和历史数据访问）"""
    
    def __init__(self, vars_store: VariableStore, t: float, instances: Dict[str, Any]):
        super().__init__(vars_store, t)
        self._instances = instances
    
    def build_env(self) -> Dict[str, Any]:
        """构造表达式环境"""
        env = super().build_env()
        
        # 添加实例属性访问（支持历史数据）
        for instance_name, instance in self._instances.items():
            # 支持 instance.attribute 和 instance.attribute[-30] 访问
            env[instance_name] = InstanceProxy(instance_name, instance, self._vars)
        
        # 添加无状态函数
        for func_name, func in InstanceRegistry._functions.items():
            env[func_name] = func
        
        return env

class InstanceProxy:
    """实例代理（用于属性访问，支持历史数据）"""
    
    def __init__(self, instance_name: str, instance: Any, vars_store: VariableStore):
        self._instance_name = instance_name
        self._instance = instance
        self._vars = vars_store
    
    def __getattr__(self, name: str):
        """获取属性值（支持历史数据访问）"""
        # 返回一个支持历史数据访问的属性代理
        return AttributeProxy(self._instance_name, name, self._instance, self._vars)

class AttributeProxy:
    """属性代理（支持当前值和历史值访问）"""
    
    def __init__(self, instance_name: str, attr_name: str, instance: Any, vars_store: VariableStore):
        self._instance_name = instance_name
        self._attr_name = attr_name
        self._instance = instance
        self._vars = vars_store
        self._var_key = f"{instance_name}.{attr_name}"
    
    def __float__(self) -> float:
        """转换为浮点数（获取当前值）"""
        # 优先从 VariableStore 获取（可能已更新）
        if self._vars.get(self._var_key) is not None:
            return float(self._vars.get(self._var_key))
        # 否则从实例属性获取
        return float(getattr(self._instance, self._attr_name, 0.0))
    
    def __getitem__(self, lag_steps: int) -> float:
        """支持 [lag_steps] 语法访问历史值"""
        if lag_steps < 0:
            # 转换为正数（-30 表示 30 步之前）
            lag_steps = -lag_steps
        return float(self._vars.get_with_lag(self._var_key, lag_steps, 0.0))
    
    def __repr__(self) -> str:
        """字符串表示"""
        return str(float(self))
```

### 2.6 执行引擎扩展 (`core/engine.py`)

```python
class UnifiedEngine:
    """统一执行引擎（扩展版）"""
    
    def __init__(self, config: ProgramConfig) -> None:
        self.config = config
        self.clock = Clock(config.clock)
        # 使用 record_length 作为历史记录长度
        self.vars = VariableStore(max_lag_steps=config.record_length)
        
        # 创建实例工厂
        self.factory = InstanceFactory(cycle_time=config.clock.cycle_time)
        
        # 创建所有实例（第 0 次执行）
        self._instances: Dict[str, Any] = {}
        self._instance_name_map: Dict[Any, str] = {}  # 实例对象 -> 实例名称的映射
        self._nodes: List[Any] = []
        
        # 分析依赖关系
        analyzer = DependencyAnalyzer()
        dependency_graph = analyzer.analyze(config.program)
        
        # 拓扑排序
        execution_order = topological_sort(dependency_graph)
        
        # 按顺序创建节点
        for name in execution_order:
            item = next(item for item in config.program if item.name == name)
            
            if item.type.upper() == 'VARIABLE':
                # Variable 类型：创建表达式节点
                node = VariableNode(
                    ExpressionConfig(name=item.name, expression=item.expression),
                    self._instances
                )
            else:
                # 算法/模型类型：创建算法节点
                instance = self.factory.create_instance(item)
                self._instances[item.name] = instance
                self._instance_name_map[instance] = item.name  # 建立反向映射
                
                # 获取存储属性列表
                stored_attrs = getattr(instance.__class__, 'stored_attributes', [])
                
                node = AlgorithmNode(instance, item.expression, stored_attrs, item.name)
            
            self._nodes.append(node)
        
        # 初始化所有实例的属性到 VariableStore（第 0 次执行）
        self._initialize_storage()
    
    def _initialize_storage(self):
        """初始化存储（第 0 次执行）"""
        # 初始化所有算法/模型实例的属性
        for instance_name, instance in self._instances.items():
            stored_attrs = getattr(instance.__class__, 'stored_attributes', [])
            for attr_name in stored_attrs:
                if hasattr(instance, attr_name):
                    value = getattr(instance, attr_name)
                    # 存储到 VariableStore，自动创建历史缓冲区
                    self.vars.set(f"{instance_name}.{attr_name}", value)
        
        # 初始化所有 Variable 类型的初始值（如果有默认值）
        for item in self.config.program:
            if item.type.upper() == 'VARIABLE':
                # Variable 的初始值在第一次 step 时设置，这里可以设置默认值 0.0
                self.vars.ensure(item.name, initial=0.0)
    
    def step_once(self) -> Dict[str, Any]:
        """执行一个周期"""
        # 1. 步进时钟
        cycle_count, need_sample, time_str, exec_ratio = self.clock.step()
        t = self.clock.sim_time
        
        # 2. 执行所有节点
        for node in self._nodes:
            if isinstance(node, VariableNode):
                node.step(self.vars, t)
            else:
                # 算法节点需要知道实例名称，用于存储属性
                node.step(self.vars, self._instances, self._instance_name_map, self.config.clock.cycle_time)
        
        # 3. 返回快照
        snapshot = self.vars.snapshot()
        snapshot["cycle_count"] = cycle_count
        snapshot["need_sample"] = need_sample
        snapshot["time_str"] = time_str
        snapshot["sim_time"] = t
        snapshot["exec_ratio"] = exec_ratio
        return snapshot
```

## 三、历史数据存储机制详解

### 3.1 存储要求

**核心要求**：
- 每个 Variable 需要存储长度为 `record_length` 的历史数据
- 每个 AlgorithmInstance 的每个属性也需要存储长度为 `record_length` 的历史数据
- 所有历史数据统一存储在 `VariableStore` 中

### 3.2 存储键名规则

- **Variable 类型**：直接使用变量名作为键
  - 例如：`non_sense_3` → 存储键为 `"non_sense_3"`
  
- **算法/模型属性**：使用 `instance_name.attribute_name` 作为键
  - 例如：`pid1.mv` → 存储键为 `"pid1.mv"`
  - 例如：`tank1.level` → 存储键为 `"tank1.level"`

### 3.3 历史数据访问语法

在表达式中支持以下语法访问历史数据：

1. **Variable 历史值**：
   ```python
   non_sense_3[-30]  # 获取 non_sense_3 的 30 步之前的值
   ```

2. **实例属性历史值**：
   ```python
   pid1.mv[-30]      # 获取 pid1.mv 的 30 步之前的值
   tank1.level[-10]  # 获取 tank1.level 的 10 步之前的值
   ```

3. **当前值访问**（无 `[-N]` 语法）：
   ```python
   non_sense_3        # 获取 non_sense_3 的当前值
   pid1.mv            # 获取 pid1.mv 的当前值
   ```

### 3.4 实现细节

#### 3.4.1 VariableStore 扩展

`VariableStore` 已经支持历史数据存储（通过 `RingBuffer`），只需要确保：
- 初始化时使用 `record_length` 作为 `max_lag_steps`
- 每次 `set()` 调用时，值会自动追加到历史缓冲区

#### 3.4.2 表达式解析扩展

在表达式解析时，需要识别以下 AST 节点：
- `ast.Subscript`：处理 `[-30]` 语法
- `ast.Attribute`：处理 `instance.attribute` 语法
- `ast.Name`：处理变量名

#### 3.4.3 属性代理实现

通过 `AttributeProxy` 类实现属性访问和历史数据访问：
- `__float__()`：获取当前值
- `__getitem__(lag_steps)`：获取历史值
- 自动从 `VariableStore` 中读取数据

### 3.5 配置示例

```yaml
# YAML 配置
record_length: 1000  # 所有变量和属性的历史记录长度

program:
  - name: pid1
    type: PID
    init_args:
      mv: 0.0
    expression: pid1.execute(pv=tank1.level, sv=sin1.out)
  
  - name: non_sense_3
    type: Variable
    expression: non_sense_3 = non_sense_1[-30] + 2 * non_sense_2
    # 支持访问 non_sense_1 的 30 步之前的值
  
  - name: non_sense_4
    type: Variable
    expression: non_sense_4 = pid1.mv[-10] * 0.5
    # 支持访问 pid1.mv 的 10 步之前的值
```

### 3.6 性能考虑

- **内存占用**：每个变量/属性需要存储 `record_length` 个浮点数
  - 例如：1000 个变量，每个 `record_length=1000`，需要约 8MB 内存（1000 * 1000 * 8 bytes）
  
- **访问性能**：使用 `deque` 实现环形缓冲区，`append()` 和 `get_by_lag()` 都是 O(1) 操作

- **初始化**：第 0 次执行时，所有变量和属性的初始值都会存储到 `VariableStore`，确保历史数据从第一个周期开始就有记录

## 四、算法库实现示例

### 4.1 PID 算法 (`algorithms/pid.py`)

```python
from data_next.core.instance import BaseAlgorithm
from data_next.core.instance import InstanceRegistry

class PID(BaseAlgorithm):
    """PID 控制算法"""
    
    stored_attributes = ['mv', 'pv', 'sv', 'pb', 'ti', 'td', 'h', 'l']  # 定义需要存储的属性
    default_params = {
        'pb': 12.0,
        'ti': 30.0,
        'td': 0.15,
        'pv': 0.0,
        'sv': 0.0,
        'mv': 0.0,
        'h': 100.0,
        'l': 0.0,
    }
    
    def __init__(self, cycle_time: float, **kwargs):
        super().__init__(cycle_time, **kwargs)
        # PID 内部状态
        self._last_error = 0.0
        self._integral = 0.0
    
    def execute(self, pv: float = None, sv: float = None) -> None:
        """执行 PID 计算"""
        if pv is not None:
            self.pv = pv
        if sv is not None:
            self.sv = sv
        
        error = self.sv - self.pv
        
        # 比例项
        p_term = self.pb * error
        
        # 积分项
        self._integral += error * self.cycle_time
        i_term = self.pb / self.ti * self._integral if self.ti > 0 else 0.0
        
        # 微分项
        d_term = self.pb * self.td * (error - self._last_error) / self.cycle_time
        self._last_error = error
        
        # 计算输出
        self.mv = p_term + i_term + d_term
        
        # 限制输出范围
        self.mv = max(self.l, min(self.h, self.mv))

# 注册算法
InstanceRegistry.register_algorithm('PID', PID)
```

### 4.2 SINE_WAVE 算法 (`programs/sine_wave.py`)

```python
import math
from core.instance import BaseProgram
from core.instance import InstanceRegistry

class SINE_WAVE(BaseProgram):
    """正弦波生成算法"""
    
    stored_attributes = ['out', 'amplitude', 'period', 'phase']
    default_params = {
        'amplitude': 100.0,
        'period': 1200.0,  # 周期（秒）
        'phase': 0.0,
    }
    
    def __init__(self, cycle_time: float, **kwargs):
        super().__init__(cycle_time, **kwargs)
        self._cycle_count = 0
    
    def execute(self) -> None:
        """执行正弦波计算"""
        cycles_per_period = self.period / self.cycle_time
        angle = 2 * math.pi * (self._cycle_count % cycles_per_period) / cycles_per_period + self.phase
        self.out = self.amplitude * math.sin(angle)
        self._cycle_count += 1

# 注册算法
InstanceRegistry.register_algorithm('SINE_WAVE', SINE_WAVE)
```

### 4.3 SQUARE_WAVE 算法 (`programs/square_wave.py`)

方波生成算法，输出在半个周期内为 amplitude，在另外半个周期内为 -amplitude。

### 4.4 TRIANGLE_WAVE 算法 (`programs/triangle_wave.py`)

三角波生成算法，输出从 -amplitude 线性增长到 amplitude，然后线性下降回 -amplitude。

### 4.5 LIST_WAVE 算法 (`programs/list_wave.py`)

列表波生成算法，根据配置的列表值和时间点循环播放。init_args 格式：`wave_list = [(v1, t1), (v2, t2), (v3, t3), ...]`，其中 v 是值，t 是该值持续的时间（秒）。

## 五、函数库实现 (`functions/math_functions.py`)

```python
import math
from data_next.core.instance import InstanceRegistry

# 注册标准数学函数
InstanceRegistry.register_function('abs', abs)
InstanceRegistry.register_function('sqrt', math.sqrt)
InstanceRegistry.register_function('sin', math.sin)
InstanceRegistry.register_function('cos', math.cos)
InstanceRegistry.register_function('tan', math.tan)
InstanceRegistry.register_function('log', math.log)
InstanceRegistry.register_function('exp', math.exp)
# ... 更多函数
```

## 六、使用示例

```python
from data_next.core.parser import DSLParser
from data_next.core.engine import UnifiedEngine

# 解析配置
parser = DSLParser()
config = parser.parse('config/dsl_demo1.yaml')

# 创建引擎
engine = UnifiedEngine(config)

# 运行
results = engine.run_for_steps(1000)
```

## 七、实现步骤

1. **第一阶段**：实现基础框架
   - 创建 `core/instance.py`（基类、注册表）
   - 创建 `core/parser.py`（DSL 解析器）
   - 创建 `core/dependency.py`（依赖分析）
   - 创建 `core/factory.py`（实例工厂）

2. **第二阶段**：扩展表达式节点
   - 扩展 `core/expression_node.py`（算法节点、扩展上下文）
   - 扩展 `core/engine.py`（支持算法节点）

3. **第三阶段**：实现算法库
   - 实现 `algorithms/pid.py`
   - 实现 `algorithms/sin.py`
   - 实现 `models/cylindrical_tank.py`
   - 实现 `models/valve.py`

4. **第四阶段**：实现函数库
   - 实现 `functions/math_functions.py`

5. **第五阶段**：测试与优化
   - 编写测试用例（包括历史数据访问测试）
   - 性能优化（历史数据存储和访问性能）
   - 文档完善

### 7.1 历史数据存储实现要点

1. **VariableStore 初始化**：
   - 使用 `record_length` 作为 `max_lag_steps`
   - 确保所有变量和属性都创建历史缓冲区

2. **属性存储**：
   - 算法节点的 `step()` 方法中，每次 `execute()` 后自动存储所有 `stored_attributes`
   - 使用 `instance_name.attribute_name` 作为存储键

3. **表达式解析**：
   - 扩展 `_resolve_expression()` 方法，支持 `[-N]` 语法
   - 支持 `instance.attribute[-N]` 和 `variable_name[-N]` 两种形式

4. **属性代理**：
   - 实现 `AttributeProxy` 类，支持 `__getitem__()` 方法访问历史值
   - 在 `ExtendedEvalContext` 中使用 `InstanceProxy` 包装实例

