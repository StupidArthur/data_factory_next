# data_next 用户手册（初版）

## 1. 目标读者

- 需要构造/调试数据模拟场景的开发同学。
- 想要统一使用“有状态 + 周期执行”方式来：
  - 快速批量生成时间序列；
  - 做实时联调或加速模拟；
  - 将已有数据以“播放”的形式供被测系统消费（后续支持）。

## 2. 基本概念

- **周期执行（cycle）**：每个周期执行一轮所有节点的计算，得到一组变量的当前值。
- **周期计数（cycle_count）**：`Clock` 维护的核心状态，从 0 开始递增。
- **模拟时间（sim_time）**：由 `Clock` 计算得出：`sim_time = start_time + cycle_count * cycle_time`。
- **执行周期（cycle_time）**：PLC 程序执行周期，例如 0.5 秒。
- **采样间隔（sample_interval）**：数据采样间隔，可以与 `cycle_time` 不同，例如每 0.5 秒执行一次，但每 5 秒采样一次。
- **表达式节点（ExpressionNode）**：
  - 通过表达式计算单个变量的当前值；
  - 可以依赖其他变量的当前值或历史值（lag）。
- **变量存储（VariableStore）**：
  - 管理所有变量的当前值和有限长度的历史记录。

## 3. 快速上手：表达式批量生成

> 下述示例仅描述使用思路，具体调用入口可以根据后续集成方式调整。

### 3.1 构造配置

```python
from data_next.core.clock import ClockConfig, ClockMode
from data_next.core.engine import EngineConfig
from data_next.core.expression_node import ExpressionConfig

clock_cfg = ClockConfig(
    cycle_time=0.5,              # PLC 执行周期：每 0.5 秒执行一次
    start_time=0.0,              # 起始时间（时间戳或 datetime）
    mode=ClockMode.GENERATOR,    # 生成器模式：不 sleep，用于批量生成
    sample_interval=5.0,         # 采样间隔：每 5 秒采样一次（每 10 个周期采样一次）
    time_format="%Y-%m-%d %H:%M:%S",  # 时间字符串格式，例如 "2024-12-02 10:30:45"
)

exprs = [
    ExpressionConfig(
        name="v1",
        expression="50 + 10 * sin(2 * pi * t / 86400.0)",
    ),
    ExpressionConfig(
        name="v2",
        expression="lag('v1', 30) * 0.5",
    ),
]

engine_cfg = EngineConfig(
    clock=clock_cfg,
    expressions=exprs,
    max_lag_steps=60,  # 至少覆盖需要的最大滞后步数
)
```

### 3.2 批量运行并收集结果

```python
from data_next.core.engine import UnifiedEngine

engine = UnifiedEngine(engine_cfg)
snapshots = engine.run_for_steps(10000)

# snapshots 是一个列表，每个元素是 dict，包含：
# - 所有变量的当前值（例如 "v1": 50.0, "v2": 25.0）
# - cycle_count: 周期计数（例如 1, 2, 3, ...）
# - need_sample: 是否需要采样（例如 True, False, False, ..., True）
# - time_str: 当前时间字符串（例如 "2024-12-02 10:30:45"）
# - sim_time: 当前模拟时间（浮点数，秒）

# 只导出需要采样的数据
sampled_data = [s for s in snapshots if s["need_sample"]]
```

之后可以将 `snapshots` 转为 Pandas DataFrame 或写入 CSV 文件。

## 4. 实时运行（预留）

当 `ClockConfig.mode` 设置为：

- `ClockMode.REALTIME`：
  - 使用 `run_forever()` 或 `run_for_steps()` 以真实时间步进（每个周期会 sleep）。
  - 适合与外部系统的实时联调。
- `ClockMode.GENERATOR`：
  - 不 sleep，快速执行，用于批量数据生成。

这些模式主要用于：

- 与外部系统的实时联调（REALTIME 模式）；
- 批量数据生成（GENERATOR 模式）；
- 未来与 Redis/OPCUA 等通信模块对接。

## 5. 注意事项

1. **滞后步数与 cycle_time 的关系**
   - `lag('v1', 30)` 中的 `30` 表示“30 个采样点”，不是 30 秒。
   - 如果需要按秒来思考，可以自行换算：`lag_steps = round(lag_seconds / cycle_time)`。

2. **历史不足时的行为**
   - 当前实现中，历史不足会返回默认值 0.0。
   - 后续会根据需求增加可配置策略（例如使用初始值、跳过计算等）。

3. **安全性**
   - 表达式执行使用 AST 白名单方式，只允许有限的节点类型与函数调用。
   - 表达式中不可使用内置函数或任意 Python 语句。

## 6. 后续扩展（规划）

- 自动从 data_factory 的配置文件构造 `EngineConfig`。
- 在 mock_server 中调用 data_next 的引擎，统一运行表达式/模型/算法。
- 提供简单的导出/播放工具函数（如：一行函数从配置生成 CSV）。


