# data_next 设计文档（初版）

## 1. 架构总览

### 1.1 模块划分

- `core/`
  - `clock.py`：统一时钟 `Clock` 与配置 `ClockConfig`、运行模式 `ClockMode`。
  - `variable.py`：变量状态与环形缓冲区，`RingBuffer` / `VariableState` / `VariableStore`。
  - `expression_node.py`：表达式节点与执行上下文，`ExpressionNode` / `ExpressionConfig` / `EvalContext` / `SafeExpression`。
  - `engine.py`：统一执行引擎 `UnifiedEngine` 与配置 `EngineConfig`。
- `utils/`
  - `logger.py`：统一日志模块，基于 `mock_server` 的实现，前缀为 `data_next`。
- `doc/`
  - 需求文档、设计文档、用户手册、交互记录。

### 1.2 运行流程（按周期）

1. 外部构造 `EngineConfig`：
   - 时钟配置 `ClockConfig`（cycle_time / 模式 / 加速倍数）。
   - 表达式节点配置列表 `ExpressionConfig`。
   - 最大滞后步数 `max_lag_steps`。
2. 构造 `UnifiedEngine(config)`：
   - 内部创建 `Clock`。
   - 创建 `VariableStore(max_lag_steps)`。
   - 基于 `ExpressionConfig` 列表创建若干 `ExpressionNode`。
3. 每个周期执行：
   - `clock.step()` → 更新周期计数，内部保存开始时间戳，返回 `(cycle_count, need_sample, time_str)`。
   - 使用 `clock.sim_time` 获取模拟时间（浮点数）用于计算。
   - 依次调用每个 `ExpressionNode.step(vars_store, t)`：
     - 构造 `EvalContext(vars_store, t)`。
     - 使用 `SafeExpression` 在安全环境中执行表达式。
     - 将结果写回 `VariableStore`，并更新历史缓冲区。
   - `clock.sleep_remaining()` → 在 REALTIME 模式下，sleep 剩余时间（考虑算法执行时间）。
     - 使用内部保存的开始时间戳计算执行时间。
     - 如果执行时间超过周期的 60%，记录警告日志。
   - 通过 `vars_store.snapshot()` 导出当前周期快照，并添加 `cycle_count`、`need_sample`、`time_str`、`sim_time` 字段。
   - 如果 `need_sample` 为 True，则记录数据（用于导出）。

## 2. 核心组件设计

### 2.1 Clock

- **核心设计理念**：
  - **核心状态是周期计数（`cycle_count`）**，而不是时间。
  - 模拟时间（`sim_time`）是计算属性：`sim_time = start_time + cycle_count * cycle_time`。
  - `step()` 方法内部根据模式决定是否等待，调用方无需关心。
  - **执行周期与采样间隔分离**：`cycle_time` 控制 PLC 执行频率，`sample_interval` 控制数据采样频率。

- **职责**：
  - 管理周期计数（`cycle_count`）作为核心状态。
  - 提供模拟时间（`sim_time`）作为计算属性。
  - 在 `step()` 内部根据模式决定是否 sleep。

- **关键字段**：
  - `cycle_time: float`：PLC 执行周期（秒），例如 0.5 表示 500ms。
  - `start_time: float | datetime`：起始时间，可以是时间戳或 datetime 对象。
  - `mode: ClockMode`：REALTIME（实时模式，每个周期 sleep）或 GENERATOR（生成器模式，不 sleep）。
  - `sample_interval: float | None`：采样间隔（秒），如果为 None 则等于 `cycle_time`（每个周期都采样）。
  - `time_format: str | None`：时间字符串格式化模板，使用 strftime 格式，例如 `"%Y%m%d"`、`"%Y-%m-%d %H:%M:%S"`、`"%y%m"`。如果为 None，则返回 ISO 格式字符串。

- **关键方法**：
  - `step() -> Tuple[int, bool, str]`：步进一个周期，返回 `(周期计数, 是否需要采样, 当前时间字符串)`。
    - 内部自动记录周期开始时间戳（用于后续计算执行时间）。
    - REALTIME 模式：不在此方法中 sleep，需要调用 `sleep_remaining()` 来 sleep 剩余时间（考虑算法执行时间）。
    - GENERATOR 模式：不 sleep，直接步进。
  - `sleep_remaining()`：在 REALTIME 模式下，sleep 剩余时间（周期时间 - 已执行时间）。
    - 使用 `step()` 时保存的内部开始时间戳来计算执行时间。
    - 同时检测执行时间是否超过周期的 60%，如果超过则记录警告日志。
    - 必须在调用 `step()` 之后调用此方法。
  - `reset(cycle_count=0)`：重置周期计数。

### 2.2 VariableStore 与 RingBuffer

- `RingBuffer`：
  - 内部使用 `collections.deque(maxlen=N)`。
  - 提供 `append(value)` 与 `get_by_lag(steps, default)`。
- `VariableState`：
  - 保存变量名、当前值，以及可选的 `RingBuffer`。
  - 更新时将当前值写入 `RingBuffer`。
- `VariableStore`：
  - 管理多个 `VariableState` 实例。
  - 提供：
    - `set(name, value)`：设置当前值并写历史。
    - `get(name, default)`：获取当前值。
    - `get_with_lag(name, steps, default)`：按步数获取历史值。
    - `snapshot()`：导出全部变量当前值，方便上层使用。

### 2.3 表达式执行子系统

#### 2.3.1 ExpressionConfig

- 对应 data_factory 中单个 argument 的一个切片，当前只保留：
  - `name: str`：输出变量名。
  - `expression: str`：表达式字符串。

#### 2.3.2 EvalContext

- 对表达式提供的环境封装：
  - `t`：当前模拟时间（秒）。
  - `var(name)`：获取变量当前值。
  - `lag(name, steps)`：基于历史缓冲区获取滞后值。
  - 数学函数：来自 `math` 模块的常见函数（sin/cos/log/exp 等）。

#### 2.3.3 SafeExpression

- 使用 `ast.parse` 解析表达式。
- 仅允许的 AST 节点：
  - `Expression` / `BinOp` / `UnaryOp` / `Call` / `Name` / `Constant` / `Num`。
- 编译为 code object 后，通过：

  ```python
  eval(compiled, {"__builtins__": {}}, env)
  ```

  在受控环境中执行。

#### 2.3.4 ExpressionNode

- 封装单个表达式节点：
  - 内部持有 `ExpressionConfig` 与一个 `SafeExpression`。
  - `step(vars_store, t)`：
    - 构造 `EvalContext`。
    - 调用 `SafeExpression.eval()` 得到数值。
    - 写入 `VariableStore`，触发历史更新。

### 2.4 UnifiedEngine

- 聚合组件：
  - 一份 `EngineConfig`。
  - 一个 `Clock`。
  - 一个 `VariableStore`。
  - 一组 `ExpressionNode`。
- 对外提供 API：
  - `step_once()`：返回单周期 snapshot。
  - `run_for_steps(steps, sleep=False)`：返回多周期 snapshot 列表。
  - `run_forever()`：生成器形式，持续输出 snapshot。

## 3. 与现有系统的映射关系（规划）

> 当前阶段只实现“表达式 + 周期执行”的通用骨架，后续再做映射：

- 从 `data_factory`：
  - 使用 arguments 配置构造 `ExpressionConfig` 列表。
  - 将原先整段 numpy 计算逻辑迁移为按周期表达式执行。
- 从 `mock_server`：
  - 将模型和 PID 算法抽象为“节点”，与表达式节点统一由引擎调度。

## 4. 设计扩展点

1. `EngineConfig` 中增加：
   - 模型节点配置列表。
   - 算法节点配置列表。
2. 执行顺序：
   - 当前默认以 `expressions` 列表顺序执行。
   - 后续可以引入类似 data_factory/mocked_server 的依赖图 + 拓扑排序。
3. 滞后策略：
   - 历史不足时的默认值策略支持配置（0 / 初始值 / 预热等）。


