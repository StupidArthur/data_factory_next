# data_next 需求文档（初版）

## 1. 背景

- `data_factory`：目前提供“批量生成完整时间序列”的能力，基于表达式和依赖图，一次性输出 DataFrame/CSV。
- `mock_server`：提供“有状态、周期执行”的 PLC 模拟能力，支持在线写值、Redis/OPCUA 通信、快照与组态更新。
- 随着需求演进：
  - `mock_server` 引入了快速模拟工具（不等待或时间加速）。
  - `data_factory` 计划把离线数据“慢慢播放”给被测系统。
- 两边的能力正在收敛，存在重复实现与逻辑不统一的问题。

## 2. 总体目标

在 `data_next` 中构建一个**统一的数据模拟与播放架构**，实现：

1. **统一的算法执行模型**
   - 以“有状态 + 周期执行”的方式作为唯一核心执行方式。
   - 批量生成、实时运行、数据播放都基于同一执行引擎。

2. **统一的时间与延迟语义**
   - 使用统一的时钟与时间步长（`cycle_time`）。
   - 延迟（lag）统一使用“步数”的概念，并通过历史缓冲区实现。

3. **统一的数据输出/消费接口**
   - 支持导出为 CSV/DataFrame（离线分析）。
   - 支持通过 Redis/OPCUA/接口供被测软件在线消费（后续集成）。

4. **面向扩展的节点类型**
   - 表达式节点（对应 data_factory 中的 arguments）。
   - 物理模型节点（对应 mock_server 的 tank/valve 等）。
   - 控制算法节点（PID 等）。
   - 文件/数据库播放节点（replay）。

## 3. 功能需求（首阶段）

### 3.1 表达式驱动的周期执行

- 支持通过配置定义若干表达式节点，例如：

  ```yaml
  expressions:
    - name: v1
      expression: "50 + 10 * sin(2 * pi * t / 86400.0)"
    - name: v2
      expression: "lag('v1', 30) * 0.5"
  ```

- 每个表达式节点：
  - 在每个周期执行一次，生成一个标量值。
  - 结果写入变量存储，并保留历史用于滞后访问。

### 3.2 滞后（lag）支持

- 提供 `lag(name, steps)` 函数：
  - `steps` 为“采样点数”，与 `cycle_time` 关联。
  - 内部通过固定长度的环形缓冲区实现。
- 历史不足时提供可配置的默认策略（当前版本先采用默认值 0.0，后续扩展）。

### 3.3 多模式运行

- 通过 `ClockConfig` 控制时钟行为：
  - REALTIME：真实时间 sleep。
  - FAST：加速 sleep。
  - NO_WAIT：不 sleep（用于批量生成）。
- 引擎提供三种调用方式：
  - `step_once()`：单周期执行。
  - `run_for_steps(steps, sleep=False)`：执行固定步数，支持可选 sleep。
  - `run_forever()`：生成器形式，外部负责中断。

## 4. 非功能需求

- **可读性与可维护性**
  - 有清晰的模块划分（时钟、变量、表达式、引擎）。
  - 每个类与函数提供完整中文注释。

- **可扩展性**
  - 现阶段先支持表达式节点，预留扩展模型节点/控制算法节点的接口。

- **与现有系统的兼容与迁移**
  - 首阶段不修改现有 `data_factory` 与 `mock_server` 的行为。
  - 后续可以逐步将部分逻辑迁入 `data_next`，并在调用层面切换。

## 5. 后续阶段需求（占位）

1. 支持从 data_factory 的 arguments 配置直接构造 `ExpressionConfig` 列表。
2. 支持从 mock_server 的 PLC 组态构造混合节点图（模型 + PID + 表达式）。
3. 支持 CSV/数据库数据的周期播放节点，并统一到同一引擎。


